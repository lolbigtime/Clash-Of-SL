# Clash of SL – BattleSim

The `ClashOfSL.BattleSim` project extracts the pieces that are required to run
an offline Clash of Clans style battle resolution. It removes the networking,
packet handling and account persistence code from the original server so that
you can plug the simulator directly into reinforcement learning pipelines.

## Features

- Parse defender layouts from the JSON payload generated by the live server.
- Replay battle command streams (building hits, troop deployments, hero toggles,
  etc.).
- Resolve troop drops against the defender layout by combining move speed,
  attack range and damage-per-second stats so the outcome matches the live
  server.
- Deterministic outcome evaluation that returns stars, destruction and battle
  duration.
- RL-friendly pipeline that lets you plug in custom policies and reward
  functions.

## Quick start

```csharp
using ClashOfSL.BattleSim;
using Newtonsoft.Json.Linq;

// 1. Load the village layout from a saved JSON payload.
JObject baseLayout = JObject.Parse(File.ReadAllText("defender.json"));

// 2. Provide a minimal stats resolver. Hook this into CSV data or your own
//    static tables. Only hitpoints and the town-hall flag are required.
IBuildingStatsProvider stats = new DelegateBuildingStatsProvider((dataId, level) =>
{
    // Look up hitpoints from your own data source.
    int hitpoints = LookupHitpoints(dataId, level);
    bool isTownHall = LookupIsTownHall(dataId);
    return new BuildingStats(hitpoints, isTownHall);
});

BattleLayout layout = BattleLayout.FromJson(baseLayout, stats);

// 3. Provide troop stats so class-4 commands can spawn live attackers.
var options = BattleSimulationOptions.Default;
options.TroopStatsProvider = new DelegateTroopStatsProvider(dataId =>
{
    if (!TryLookupTroop(dataId, out TroopData data))
    {
        return null;
    }

    return new TroopStats(
        dataId,
        data.Hitpoints,
        data.DamagePerSecond,
        data.MoveSpeed,
        data.AttackRange,
        data.IsFlying,
        data.PreferredTargets,
        data.PreferredTargetMultiplier);
});

var simulator = new BattleSimulator(layout, options);

// 4. Queue commands. In practice these come from your agent/policy.
var commands = new[]
{
    new BattleCommand(tick: 100, dataId: 19000000, x: 45, y: 32),
    new BattleCommand(tick: 300, dataId: 19000001, x: 50, y: 28)
};

BattleResult result = simulator.Run(commands);
Console.WriteLine($"Stars: {result.Stars}, Destruction: {result.DestructionPercentage}%");
```

## Command-line runner

If you just want to resolve a battle without wiring up any additional
infrastructure, the `BattleSim.Runner` console application can be published as a
self-contained executable. It reads a defender layout, a lightweight stats
definition and an optional command list – nothing else is required.

```bash
# Run the bundled sample battle
dotnet run --project BattleSim.Runner \
  -- --layout BattleSim/Samples/layout.json \
     --stats BattleSim/Samples/stats.json \
     --commands BattleSim/Samples/commands.json

# Launch the interactive test interface (prompts for commands)
dotnet run --project BattleSim.Runner \
  -- --layout BattleSim/Samples/layout.json \
     --stats BattleSim/Samples/stats.json \
     --interactive

# Publish a standalone executable for Windows (replace the RID as needed)
dotnet publish BattleSim.Runner/BattleSim.Runner.csproj \
  -c Release -r win-x64 --self-contained true
```

The stats file is a small JSON document that maps Clash `data` ids and levels to
hitpoints. You can expand it with your own balance values. The runner will
surface detailed error messages when a mapping is missing so you can iterate
quickly without diving into the original server.

When `--interactive` is passed the runner switches into a lightweight testing
interface. Enter commands as `tick dataId x y`, press <kbd>Enter</kbd> on an
empty line to run the simulation, or type `sample` to load the built-in command
script. The sequence is also available as
`BattleSim/Samples/user-commands.txt` so you can paste it directly into the
prompt or adapt it for your own testing harness.

### Sample data set

All of the example files shipped under `BattleSim/Samples/` are intentionally
minimal so you can understand what the simulator expects:

- **Base layout (`layout.json`)** – a Town Hall and two auxiliary buildings are
  clustered near the center of the 100×100 tile map alongside a builder hut
  instance (`dataId: 500000001`). This mirrors the defensive footprint that the
  bundled `commands.json` targets.
- **Empty base (`layout-empty.json`)** – demonstrates the schema for a defender
  with no structures at all. Running the simulator against this layout will
  instantly yield a three-star, 100% result because there is nothing to destroy.
- **Troop/balance data (`stats.json`)** – in addition to building hitpoints the
  sample stats file ships with a minimal troop entry (a dragon) so you can drop
  a class-4 command and watch it melt the Town Hall. Expand this document with
  your own troop roster to match the balance tables you're targeting.
- **Command streams** – multiple variants are included so you can validate your
  integrations:
  - `commands.json` replays the four-drop sequence that wipes out the sample
    base.
  - `commands-empty.json` is an empty array; it is useful for verifying that
    your harness handles the “no actions issued” case.
  - `commands-dragon-corner.json` drops a single dragon at tick 0 to showcase
    troop-driven destruction.
Feel free to duplicate these files and tweak coordinates, tick timings or data
ids to align them with your own scenarios.

## Reinforcement learning pipeline

For large scale training it is often convenient to orchestrate multiple
simulations in batches. `RLBattlePipeline` wraps that flow: provide a factory
that spawns fresh `BattleSimulator` instances per episode and plug in a policy
that emits commands and computes rewards.

```csharp
var seeds = Enumerable.Range(0, 32).Select(index =>
    new RLEpisodeSeed(() => new BattleSimulator(layout)));

IRLBattleCommandGenerator generator = new RandomizedCommandGenerator(commands);
IRLBattlePolicy policy = new WeightedRewardPolicy(generator);

var pipeline = new RLBattlePipeline();
IReadOnlyList<RLEpisodeResult> results = pipeline.RunEpisodes(seeds, policy);
```

You can replace `RandomizedCommandGenerator` with a custom generator that samples
from your agent. `WeightedRewardPolicy` is provided as a simple default – the
reward heavily weights stars, uses destruction percentage as a tie breaker and
adds a small bonus for finishing the battle faster.

## Building

```
dotnet build BattleSim/ClashOfSL.BattleSim.csproj
```

The project targets .NET Standard 2.0 so it can be referenced from modern .NET
applications, Unity projects and Python interop layers.
